
单例模式：
    保证一个类仅有一个实例，并提供一个访问它的全局访问点。
    单例模式是一种常用的设计模式，有一些对象我们只需要一个，比如线程池、全局缓存、浏览器中window对象等。

    惰性单例：需要的时候才创建对象实例

----------------------------------------

策略模式：
    定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换

    策略模式的优点：
        1、策略模式利用组合、委托和多态等技术思想，可以有效避免多重条件选择语句
        2、策略模式提供了对开放-封闭原则的完美支持，将算法封装在独立的strategy中，使得它易于切换，易于理解，易于扩展
        3、策略模式中的算法也可以复用在系统的其他地方，从而避免许多重复的复制粘贴工作
        4、在策略模式中利用组合和委托来让Context拥有执行算法的能力，这也是继承的一种更轻便的替代方案

----------------------------------------

代理模式：
    是为一个对象提供一个代用品或占位符，以便控制对它的访问

    虚拟代理：虚拟代理会把一些开销很大的对象，延迟到真正需要它的时候才去创建
    缓存代理：缓存代理可以为一些开销大的运算结果提供暂时的存储，下次运算时，如果传递过来的参数跟之前一致，则可以直接返回前面存储的运算结果

    其他代理模式：
        防火墙代理：控制网络资源的访问，保护主题不让"坏人"接近
        远程代理：为一个对象再不同的地址空间提供局部代表，在JAVA中，远程代理可以是另一个虚拟机中的对象
        保护代理：用于对象应该有不同访问权限的情况
        智能引用代理：取代了简单的指针，它在访问对象时执行一些附加操作，比如计算一个对象被引用的次数
        写时复制代理：通常用于复制一个庞大对象的情况，写时复制代理延迟了复制的过程，当对象被真正修改时，才对它进行复制操作。写时复制代理是虚拟代理的一种变体

----------------------------------------

迭代器模式：
    迭代器模式是指提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴漏该对象的内部表示。迭代器模式可以把迭代的过程从业务逻辑分离出来，使用迭代器模式之后，即使不关心对象的内部构造，也可以按顺序访问其中的每个元素。

    内部迭代器：内部迭代器在调用的时候非常方便，外界不关系迭代器内部的实现，跟迭代器的交互也仅是一次初始调用，但这也刚好是内部迭代器的缺点。由于内部迭代器的迭代规则已经被提前规定，就无法同时迭代2个数组了
    外部迭代器：外部迭代器增加了一些调用的复杂度，但相对也增强了迭代器的灵活性，我们可以手工控制迭代的过程或顺序。

----------------------------------------

观察者模式：
    它定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。在JavaScript开发中，我们一般用事件模型来替代观察者模式。

    如何实现观察者模式：
        1、首先指定好谁充当发布者
        2、然后给发布者添加一个缓存列表，用于存放回调函数以便通知订阅者
        3、最后发布消息的时候，发布者会遍历这个缓存列表，依次触发里面存放的订阅者回调函数

----------------------------------------

命令模式：
    
















