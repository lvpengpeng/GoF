
单例模式：
    保证一个类仅有一个实例，并提供一个访问它的全局访问点。
    单例模式是一种常用的设计模式，有一些对象我们只需要一个，比如线程池、全局缓存、浏览器中window对象等。

    惰性单例：需要的时候才创建对象实例

----------------------------------------

策略模式：
    定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换

    策略模式的优点：
        1、策略模式利用组合、委托和多态等技术思想，可以有效避免多重条件选择语句
        2、策略模式提供了对开放-封闭原则的完美支持，将算法封装在独立的strategy中，使得它易于切换，易于理解，易于扩展
        3、策略模式中的算法也可以复用在系统的其他地方，从而避免许多重复的复制粘贴工作
        4、在策略模式中利用组合和委托来让Context拥有执行算法的能力，这也是继承的一种更轻便的替代方案

----------------------------------------

代理模式：
    是为一个对象提供一个代用品或占位符，以便控制对它的访问

    虚拟代理：虚拟代理会把一些开销很大的对象，延迟到真正需要它的时候才去创建
    缓存代理：缓存代理可以为一些开销大的运算结果提供暂时的存储，下次运算时，如果传递过来的参数跟之前一致，则可以直接返回前面存储的运算结果

    其他代理模式：
        防火墙代理：控制网络资源的访问，保护主题不让"坏人"接近
        远程代理：为一个对象再不同的地址空间提供局部代表，在JAVA中，远程代理可以是另一个虚拟机中的对象
        保护代理：用于对象应该有不同访问权限的情况
        智能引用代理：取代了简单的指针，它在访问对象时执行一些附加操作，比如计算一个对象被引用的次数
        写时复制代理：通常用于复制一个庞大对象的情况，写时复制代理延迟了复制的过程，当对象被真正修改时，才对它进行复制操作。写时复制代理是虚拟代理的一种变体

----------------------------------------

迭代器模式：
    迭代器模式是指提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴漏该对象的内部表示。迭代器模式可以把迭代的过程从业务逻辑分离出来，使用迭代器模式之后，即使不关心对象的内部构造，也可以按顺序访问其中的每个元素。

    内部迭代器：内部迭代器在调用的时候非常方便，外界不关系迭代器内部的实现，跟迭代器的交互也仅是一次初始调用，但这也刚好是内部迭代器的缺点。由于内部迭代器的迭代规则已经被提前规定，就无法同时迭代2个数组了
    外部迭代器：外部迭代器增加了一些调用的复杂度，但相对也增强了迭代器的灵活性，我们可以手工控制迭代的过程或顺序。

----------------------------------------

观察者模式：
    它定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。在JavaScript开发中，我们一般用事件模型来替代观察者模式。

    如何实现观察者模式：
        1、首先指定好谁充当发布者
        2、然后给发布者添加一个缓存列表，用于存放回调函数以便通知订阅者
        3、最后发布消息的时候，发布者会遍历这个缓存列表，依次触发里面存放的订阅者回调函数

----------------------------------------

命令模式：
    有时候需要向某些对象发送请求，但是并不知道请求的接受者是谁，也不知道被请求的操作是什么，此时希望用一种松耦合的方式来设计软件，使得请求发送者和请求接收者能够消除彼此之间的耦合关系。

----------------------------------------

组合模式：
    组合模式就是用小的子对象来构建更大的对象，而这些小的子对象本身也许是由更小的"孙对象"构成的。

    组合模式将对象组合成树形结构，以表示"部分-整体"的层次结构。除了用来表示树形结构之外，组合模式的另一个好处是通过对象的多态性表现，使得用户对单个对象和组合对象的使用具有一致性。

    组合模式最大的有点在于可以一致地对待组合对象和基本对象。客户不需要知道当前处理的是宏命令还是普通命令，只要它是一个命令，并且有execute方法，这个命令就可以被添加到树中。

    注意：
        1、组合模式不是父子关系：组合模式的树型结构容易让人误以为组合对象和叶对象是父子关系，这是不正确的。组合模式是一种HAS-A(聚合)的关系，而不是IS-A。组合对象包含一组叶对象，但Leaf并不是Composite的子类。组合对象把请求委托给它所包含的所有叶对象，它们能够合作的关键是拥有相同的接口。
        2、对叶对象操作的一致性：组合模式除了要求组合对象和叶对象拥有相同的接口之外，还有一个必要条件，就是对一组叶对象的操作必须具有一致性。
        比如公司要给全体员工发放元旦过节费1000元，这个场景可以运用组合模式。但如果公司给今天过生日的员工发生日祝福，组合模式就没有用武之地了。
        3、双向映射关系：发过节费是发送给部门，依次下发，但是如果有员工隶属于多个部门，适不适合使用组合模式的。
        4、用职责链模式提高组合模式性能：在组合模式中，如果树的结构比较复杂，节点数量很多，在遍历树的过程中，性能方面也许表现得不够理想。有时候我们确实可以借助一些技巧，在实际操作中避免遍历整棵树，有一种现成的方案是借助职责链模式。职责链模式一般需要我们手动去设置链条，但在组合模式中，父对象和子对象之间实际上形成了天然的职责链。让请求顺着链条从父对象往子对象传递，或者是反过来从子对象往父对象传递，直到遇到可以处理该请求的对象为止，这也是职责链模式的经典运用场景之一。
    何时使用组合模式：
        1、表示对象的部分-整体层次结构。组合模式可以方便地构造一棵树来表示对象的部分-整体结构。特别是我们在开发期间不确定这棵树到底存在多少层次的时候。在树的构造最终完成之后只需要通过请求树的最顶层对象，便能对整颗树做一个统一的操作。在组合模式中增加和删除树的节点非常方便，并且符合开放-封闭原则。
        2、客户希望统一对待树中所有对象。组合模式使客户可以忽略组合对象和叶对象的区别，客户在面对这棵树的时候，不用关心当前正在处理的对象是组合对象还是叶对象，也就是不用写一堆if、else语句来分别处理它们。组合对象和叶对象会各自做自己正确的事情，这才是组合模式最重要的能力。
    然而组合模式并不是完美的，它可能会产生一个这样的系统：系统中每个对象看起来都和其他对象差不多。它们的区别只有在运行的时候才会显现出来，这会使代码难以理解。

----------------------------------------













