
单例模式：
    保证一个类仅有一个实例，并提供一个访问它的全局访问点。
    单例模式是一种常用的设计模式，有一些对象我们只需要一个，比如线程池、全局缓存、浏览器中window对象等。

    惰性单例：需要的时候才创建对象实例

----------------------------------------

策略模式：
    定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换

    策略模式的优点：
        1、策略模式利用组合、委托和多态等技术思想，可以有效避免多重条件选择语句
        2、策略模式提供了对开放-封闭原则的完美支持，将算法封装在独立的strategy中，使得它易于切换，易于理解，易于扩展
        3、策略模式中的算法也可以复用在系统的其他地方，从而避免许多重复的复制粘贴工作
        4、在策略模式中利用组合和委托来让Context拥有执行算法的能力，这也是继承的一种更轻便的替代方案

----------------------------------------

代理模式：
    是为一个对象提供一个代用品或占位符，以便控制对它的访问

    虚拟代理：虚拟代理会把一些开销很大的对象，延迟到真正需要它的时候才去创建
    缓存代理：缓存代理可以为一些开销大的运算结果提供暂时的存储，下次运算时，如果传递过来的参数跟之前一致，则可以直接返回前面存储的运算结果

    其他代理模式：
        防火墙代理：控制网络资源的访问，保护主题不让"坏人"接近
        远程代理：为一个对象再不同的地址空间提供局部代表，在JAVA中，远程代理可以是另一个虚拟机中的对象
        保护代理：用于对象应该有不同访问权限的情况
        智能引用代理：取代了简单的指针，它在访问对象时执行一些附加操作，比如计算一个对象被引用的次数
        写时复制代理：通常用于复制一个庞大对象的情况，写时复制代理延迟了复制的过程，当对象被真正修改时，才对它进行复制操作。写时复制代理是虚拟代理的一种变体

----------------------------------------

迭代器模式：
    迭代器模式是指提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴漏该对象的内部表示。迭代器模式可以把迭代的过程从业务逻辑分离出来，使用迭代器模式之后，即使不关心对象的内部构造，也可以按顺序访问其中的每个元素。

    内部迭代器：内部迭代器在调用的时候非常方便，外界不关系迭代器内部的实现，跟迭代器的交互也仅是一次初始调用，但这也刚好是内部迭代器的缺点。由于内部迭代器的迭代规则已经被提前规定，就无法同时迭代2个数组了
    外部迭代器：外部迭代器增加了一些调用的复杂度，但相对也增强了迭代器的灵活性，我们可以手工控制迭代的过程或顺序。

----------------------------------------

观察者模式：
    它定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。在JavaScript开发中，我们一般用事件模型来替代观察者模式。

    如何实现观察者模式：
        1、首先指定好谁充当发布者
        2、然后给发布者添加一个缓存列表，用于存放回调函数以便通知订阅者
        3、最后发布消息的时候，发布者会遍历这个缓存列表，依次触发里面存放的订阅者回调函数

----------------------------------------

命令模式：
    有时候需要向某些对象发送请求，但是并不知道请求的接受者是谁，也不知道被请求的操作是什么，此时希望用一种松耦合的方式来设计软件，使得请求发送者和请求接收者能够消除彼此之间的耦合关系。

----------------------------------------

组合模式：
    组合模式就是用小的子对象来构建更大的对象，而这些小的子对象本身也许是由更小的"孙对象"构成的。

    组合模式将对象组合成树形结构，以表示"部分-整体"的层次结构。除了用来表示树形结构之外，组合模式的另一个好处是通过对象的多态性表现，使得用户对单个对象和组合对象的使用具有一致性。

    组合模式最大的有点在于可以一致地对待组合对象和基本对象。客户不需要知道当前处理的是宏命令还是普通命令，只要它是一个命令，并且有execute方法，这个命令就可以被添加到树中。

    注意：
        1、组合模式不是父子关系：组合模式的树型结构容易让人误以为组合对象和叶对象是父子关系，这是不正确的。组合模式是一种HAS-A(聚合)的关系，而不是IS-A。组合对象包含一组叶对象，但Leaf并不是Composite的子类。组合对象把请求委托给它所包含的所有叶对象，它们能够合作的关键是拥有相同的接口。
        2、对叶对象操作的一致性：组合模式除了要求组合对象和叶对象拥有相同的接口之外，还有一个必要条件，就是对一组叶对象的操作必须具有一致性。
        比如公司要给全体员工发放元旦过节费1000元，这个场景可以运用组合模式。但如果公司给今天过生日的员工发生日祝福，组合模式就没有用武之地了。
        3、双向映射关系：发过节费是发送给部门，依次下发，但是如果有员工隶属于多个部门，适不适合使用组合模式的。
        4、用职责链模式提高组合模式性能：在组合模式中，如果树的结构比较复杂，节点数量很多，在遍历树的过程中，性能方面也许表现得不够理想。有时候我们确实可以借助一些技巧，在实际操作中避免遍历整棵树，有一种现成的方案是借助职责链模式。职责链模式一般需要我们手动去设置链条，但在组合模式中，父对象和子对象之间实际上形成了天然的职责链。让请求顺着链条从父对象往子对象传递，或者是反过来从子对象往父对象传递，直到遇到可以处理该请求的对象为止，这也是职责链模式的经典运用场景之一。
    何时使用组合模式：
        1、表示对象的部分-整体层次结构。组合模式可以方便地构造一棵树来表示对象的部分-整体结构。特别是我们在开发期间不确定这棵树到底存在多少层次的时候。在树的构造最终完成之后只需要通过请求树的最顶层对象，便能对整颗树做一个统一的操作。在组合模式中增加和删除树的节点非常方便，并且符合开放-封闭原则。
        2、客户希望统一对待树中所有对象。组合模式使客户可以忽略组合对象和叶对象的区别，客户在面对这棵树的时候，不用关心当前正在处理的对象是组合对象还是叶对象，也就是不用写一堆if、else语句来分别处理它们。组合对象和叶对象会各自做自己正确的事情，这才是组合模式最重要的能力。
    然而组合模式并不是完美的，它可能会产生一个这样的系统：系统中每个对象看起来都和其他对象差不多。它们的区别只有在运行的时候才会显现出来，这会使代码难以理解。

----------------------------------------

模板方法模式：
    模板方法模式是一种只需要使用继承就可以实现的非常简单的模式。
    模板方法模式由两部分结构组成，第一部分是抽象父类，第二部分是具体的实现子类。通常在抽象父类中封装了子类的算法框架，包括实现一些公共方法以及封装子类中所有方法的执行顺序。子类通过集成这个抽象类，也继承了整个算法结构，并且可以选择重写父类的方法。
    假如我们有一些平行的子类，各个子类之间有一些相同的行为，也有一些不同的行为。如果相同和不同的行为都混合在各个子类的实现中，说明这些相同的行为会在各个子类中重复出现。但实际上，相同的行为可以被搬移到另外一个单一的地方，模板方法模式就是为解决这个问题而生的。在模板方法模式中，子类实现中的相同部分被上移到父类中，而将不同的部分留待子类来实现。

    Coffee or Tea：
        泡咖啡和泡茶主要有一下不同点：
            1、原料不同：一个是咖啡，一个是茶，但我们可以把它们都抽象为"饮料"
            2、泡的方式不同：咖啡是冲泡，茶是浸泡，但我们可以把它们都抽象为"泡"
            3、加的调料不同：一个是糖和牛奶，一个是柠檬，但我们可以把他们都抽象为"调料"
        泡咖啡和泡茶的步骤：
            1、把水煮沸
            2、用沸水冲泡饮料
            3、把饮料倒进杯子
            4、加调料

    钩子方法：
        放置钩子是隔离变化的一种常见手段。我们在父类中容易变化的地方放置钩子，钩子可以有一个默认的实现，究竟要不要"挂钩"，这由子类自行决定。钩子方法的返回结果决定了模板方法后面部分的执行步骤，也就是程序接下来的走向。

    模板方法模式是一种典型的通过封装变化提高系统扩展性的设计模式。在系统的面相对象语言中，一个运用了模板方法的程序中，子类的方法种类和执行顺序都是不变的，所以我们把这部分逻辑抽象到父类的模板方法里面。而子类的方法具体怎么实现是可变的，于是我们把这部分变化的逻辑封装到子类中。通过增加新的子类，我们便能给系统增加新的功能，并不需要改动抽象父类以及其他子类，这也符合开放-封闭原则。

----------------------------------------

职责链模式：
    使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系，将这些对象连成一条链，并沿着这条链传递给请求，直到有一个对象处理它为止。

----------------------------------------

 适配器模式：
    适配器模式的作用是解决两个软件实体间的接口不兼容的问题。使用适配器模式之后，原本由于接口不兼容而不能工作的两个软件实体可以一起工作。

    1、适配器模式主要用来解决两个已有接口之间不匹配的问题，它不考虑这些接口是怎样实现的，也不考虑它们将来可能会如何演化。适配器模式不需要改变已有的接口，就能够使它们协同作用。
    2、装饰着模式和代理模式也不会改变原有对象的接口，但装饰着模式的作用是为了给对象增加功能。装饰着模式常常形成一条长的装饰链，而适配器模式通常只包装一次。代理模式是为了控制对对象的访问，通常也只包装一次。
    3、外观模式的作用倒是和适配器比较相似，有人把外观模式看成一组对象的适配器，但外观模式最显著的特点是定义了一个新的接口。

----------------------------------------







